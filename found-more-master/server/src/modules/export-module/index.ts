import { format } from "date-fns"
import * as excel from "exceljs"
import * as path from "path"
import { BrandWhereUniqueInput, Prisma } from "../../generated/prisma"
import { darkGrey, grey } from "../color-module"
import { uploadFile } from "../file-module"
import { getTab as getCustomerTab } from "./tab-customer"
import { getTab as getFoundTab } from "./tab-found"
import { getTab as getItemsTab } from "./tab-items"
import { getTab as getLogisticsTab } from "./tab-logistics"
import { getTab as getSupplierTab } from "./tab-supplier"
import { ColumnDefinition, DataTab, ExportContext } from "./types"

/*

Stel er wordt een order geplaatst:
  * 2 displays
  * 1 lamp
  voor:
  * Media Markt Amsterdam Noord
  * Media Markt Amsterdam Zuid

Dan hebben we 4 suborders:
  1. Media Markt Amsterdam Noord - <ORDERNUMMER A> - 2 displays
  2. Media Markt Amsterdam Noord - <ORDERNUMMER A> - 1 lamp
  3. Media Markt Amsterdam Zuid  - <ORDERNUMMER B> - 2 displays
  4. Media Markt Amsterdam Zuid  - <ORDERNUMMER B> - 1 lamp

Found, iedere regel is een suborder:

  Winkel
  adres
  stad
  land
  taal
  Gebruiker
  Aantal
  Itemnaam
  Elementen (meerdere kolommen)
    Elementnaam
    Artikelnummer
    Aantal

Klant, iedere regelper order:

  Winkel
  adres
  stad
  land
  taal
  Gebruiker
  Elementen (lange lijst)
    Itemnaam
    Itemnummer
    Aantal

Leverancier, per element

  Elementnaam
  Artikelnummer
  Aantal
  Verwerking / verpakking
  Notities

Handling, per suborder (een order bevat dus meerdere regels!):

  Aantal
  Itemnaam
  Bestelnummer
  Elementen
    Elementnaam
    Artikelnummer
    Aantal

Logistiek, per order:

  Winkel
  adres
  stad
  land
  taal
  contacpersoon
  telefoonnr

    Itemnaam
    Bestelnummer
    Aantal
    */

export async function exportBrandData(db: Prisma, userId: string, type: "found" | "default", brandWhereUniqueInput: BrandWhereUniqueInput) {

  // Create the context
  const exportContext = { db, userId, type, brandWhereUniqueInput } as ExportContext

  // Create the workbook
  const workbook = await createWorkbook(exportContext)

  // Write the workbook
  const { name, file } = await writeWorkbook(workbook, exportContext)

  // Upload the file to s3
  const fileInput = await uploadFile(name, file)

  // Add entry to the db
  return await db.mutation.createFile({ data: fileInput })
}

async function createWorkbook(eCtx: ExportContext) {

  // Get the tabs
  const tabs = await getDataTabs(eCtx)

  // Create the workbook
  const workbook = new excel.Workbook()
  await addMetaTab(workbook, eCtx, tabs)
  await addDataTabs(workbook, tabs)

  return workbook
}

async function writeWorkbook(workbook: excel.Workbook, eCtx: ExportContext) {

  // Write the workbook to the /tmp/ dir with an unique name
  const { domain } = await eCtx.db.query.brand({ where: eCtx.brandWhereUniqueInput }, "{ domain }")
  const name = domain + "-export-" + (new Date().getTime()) + ".xlsx"
  const file = path.join("/tmp", name)
  await workbook.xlsx.writeFile(file)

  return { name, file }
}

async function addMetaTab(workbook: excel.Workbook, eCtx: ExportContext, tabs: DataTab[]) {

  // Get the data
  const brand = await eCtx.db.query.brand({ where: eCtx.brandWhereUniqueInput }, `{
    name
    domain
  }`)

  const user = await eCtx.db.query.user({ where: { id: eCtx.userId } }, `{
    firstName
    lastName
    email
  }`)

  // Format into intermediate format (with t: as text, c: as color)
  interface DataRow {
    t: string,
    c?: string
  }
  const dataRows = [
    [{ t: "General info", c: darkGrey }, { t: "", c: darkGrey }],
    [],
    [{ t: "Name", c: grey }, { t: brand.name, c: grey }],
    [{ t: "Domain", c: grey }, { t: brand.domain, c: grey }],
    [{ t: "Generated at", c: grey }, { t: format(new Date(), "dddd, Do of MMMM YYYY"), c: grey }],
    [{ t: "Generated by", c: grey }, { t: `${user.firstName} ${user.lastName} (${user.email})`, c: grey }],
    [],
    [{ t: "Sheet info", c: darkGrey }, { t: "", c: darkGrey }],
    [],
  ] as DataRow[][]

  for (const tab of tabs) {
    dataRows.push([{ t: tab.name, c: grey }, { t: tab.description, c: grey }])
    for (const column of tab.columns) {
      dataRows.push([{ t: column.name, c: column.color }, { t: column.description, c: column.color }])
    }
    dataRows.push([])
  }

  // Create the sheet
  const metaSheet = workbook.addWorksheet("Meta", { properties: { tabColor: { argb: "FF" + darkGrey } } })

  metaSheet.getColumn(1).width = 35
  metaSheet.getColumn(2).width = 55

  dataRows.forEach((dataRow, i) => {
    const row = metaSheet.getRow(i + 1)
    dataRow.forEach((dataCell, j) => {
      row.getCell(j + 1).value = dataCell.t
      row.getCell(j + 1).fill = {
        type: "pattern",
        pattern: "solid",
        fgColor: { argb: "FF" + dataCell.c },
      } as excel.FillPattern
    })
  })
}

async function addDataTabs(workbook: excel.Workbook, tabs: DataTab[]) {

  for (const tab of tabs) {

    const sheet = workbook.addWorksheet(tab.name, {
      views: [{ state: "frozen", xSplit: 1, ySplit: 1 }],
    })

    const columns = tab.columns.map((o) => ({
      header: o.name,
      key: o.key,
      style: {
        fill: {
          type: "pattern",
          pattern: "solid",
          fgColor: { argb: "FF" + o.color },
        } as excel.FillPattern,
      },
      width: 25, // (Bug) Width is required for Microsoft Office a visible state
    }))

    // Add the possible sub columns
    if (tab.columns.length > 0 && tab.columns[tab.columns.length - 1].subColumns) {
      const c = tab.columns[tab.columns.length - 1]
      for (let i = 1; i < c.maxSubColumnRepeats * c.subColumns.length; i++) {
        columns.push({
          header: "",
          key: c.key + i,
          style: {
            fill: {
              type: "pattern",
              pattern: "solid",
              fgColor: { argb: "FF" + c.color },
            } as excel.FillPattern,
          },
          width: 25,
        })
      }
    }

    sheet.columns = columns

    tab.data.forEach((row) => sheet.addRow(createDataRow(tab.columns, row)))
  }
}

async function getDataTabs(eCtx: ExportContext) {
  if (eCtx.type === "found") {
    return [
      await getFoundTab(eCtx),
      await getCustomerTab(eCtx),
      await getSupplierTab(eCtx),
      await getLogisticsTab(eCtx),
      await getItemsTab(eCtx),
    ]
  } else {
    return [
      await getCustomerTab(eCtx),
      await getItemsTab(eCtx)
    ]
  }
}

function createDataRow(columns: ColumnDefinition[], data: object) {

  const result = [] as string[]

  // Some important, but unenforced rules:
  // Only the last column definition has subcolumns
  // The subColumns do not have subColumns themselves

  for (const column of columns) {

    const val = getValue(column.key.split("."), data)

    if (column.subColumns) {

      if (Array.isArray(val)) {
        for (const v of val) {
          for (const subColumn of column.subColumns) {
            result.push(getValue(subColumn.key.split("."), v as object) as string)
          }
        }
      }
    } else {
      result.push(val as string)
    }
  }

  return result
}

function getValue(words: string[], data: object): string | object {

  if (words.length === 1) {
    return data[words[0]] ? data[words[0]] : ""
  }

  const word = words.shift()

  return data[word] ? getValue(words, data[word]) : ""
}
